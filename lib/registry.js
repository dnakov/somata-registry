// Generated by CoffeeScript 1.10.0
(function() {
  var BUMP_FACTOR, Registry, SERVICE_HOST, VERBOSE, checkServices, deregisterService, findServices, getHealthyServiceByName, getService, getServiceById, heartbeat, heartbeats, isHealthy, log, registerService, registered, registry, registry_methods, registry_options, somata,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  somata = require('somata');

  log = somata.log;

  VERBOSE = process.env.SOMATA_VERBOSE || false;

  SERVICE_HOST = process.env.SOMATA_SERVICE_HOST;

  BUMP_FACTOR = 1.5;

  registered = {};

  heartbeats = {};

  registerService = function(client_id, service_instance, cb) {
    var service_id, service_name;
    service_name = service_instance.name;
    service_instance.client_id = client_id;
    service_id = service_instance.id;
    log.s("Registering " + service_id, service_instance);
    registered[service_name] || (registered[service_name] = {});
    registered[service_name][service_id] = service_instance;
    heartbeats[client_id] = new Date().getTime() + 5000 * 1.5;
    return cb(null, service_instance);
  };

  deregisterService = function(service_name, service_id, cb) {
    var ref, ref1, service_instance;
    log.w("Deregistering " + service_id);
    if (service_instance = (ref = registered[service_name]) != null ? ref[service_id] : void 0) {
      if ((ref1 = registered[service_name]) != null) {
        delete ref1[service_id];
      }
      registry.publish('deregister', service_instance);
    }
    return typeof cb === "function" ? cb(null, service_id) : void 0;
  };

  isHealthy = function(service_instance) {
    var is_healthy, next_heartbeat;
    next_heartbeat = heartbeats[service_instance.client_id];
    is_healthy = next_heartbeat > new Date().getTime();
    if (!is_healthy) {
      log.w("Heartbeat overdue by " + (new Date().getTime() - next_heartbeat));
      deregisterService(service_instance.name, service_instance.id);
    }
    return is_healthy;
  };

  checkServices = function() {
    var results, service_id, service_instance, service_instances, service_name;
    results = [];
    for (service_name in registered) {
      service_instances = registered[service_name];
      results.push((function() {
        var results1;
        results1 = [];
        for (service_id in service_instances) {
          service_instance = service_instances[service_id];
          results1.push(isHealthy(service_instance));
        }
        return results1;
      })());
    }
    return results;
  };

  setInterval(checkServices, 2000);

  findServices = function(cb) {
    return cb(null, instances);
  };

  getHealthyServiceByName = function(service_name) {
    var instance, service_id, service_instances;
    service_instances = registered[service_name];
    for (service_id in service_instances) {
      instance = service_instances[service_id];
      if (isHealthy(instance)) {
        return instance;
      }
    }
    return null;
  };

  getServiceById = function(service_id) {
    var ref, service_name;
    service_name = service_id.split('~')[0];
    return (ref = registered[service_name]) != null ? ref[service_id] : void 0;
  };

  getService = function(service_name, cb) {
    var service_instance;
    if (service_instance = getHealthyServiceByName(service_name)) {
      return cb(null, service_instance);
    } else {
      log.i("No healthy instances for " + service_name);
      return cb("No healthy instances for " + service_name);
    }
  };

  heartbeat = function(service_id, cb) {
    var bump_time, service_instance;
    if (service_instance = getServiceById(service_id)) {
      bump_time = service_instance.heartbeat * BUMP_FACTOR;
      heartbeats[service_id] = new Date().getTime() + bump_time;
      return cb(null, true);
    } else {
      log.w("No known service " + service_id);
      return cb("No known service " + service_id, false);
    }
  };

  registry_methods = {
    registerService: registerService,
    deregisterService: deregisterService,
    findServices: findServices,
    getService: getService,
    heartbeat: heartbeat
  };

  registry_options = {
    rpc_options: {
      port: 8420
    }
  };

  Registry = (function(superClass) {
    extend(Registry, superClass);

    function Registry() {
      return Registry.__super__.constructor.apply(this, arguments);
    }

    Registry.prototype.register = function(cb) {
      return console.log("Who registers the registry?");
    };

    Registry.prototype.deregister = function(cb) {
      console.log("Who deregisters the registry?");
      return cb();
    };

    Registry.prototype.handleMethod = function(client_id, message) {
      if (message.method === 'registerService') {
        return registerService.apply(null, [client_id].concat(slice.call(message.args), [(function(_this) {
          return function(err, response) {
            return _this.sendResponse(client_id, message.id, response);
          };
        })(this)]));
      } else {
        return Registry.__super__.handleMethod.apply(this, arguments);
      }
    };

    Registry.prototype.gotPing = function(client_id) {
      var bump_time;
      bump_time = 5000 * BUMP_FACTOR;
      return heartbeats[client_id] = new Date().getTime() + bump_time;
    };

    return Registry;

  })(somata.Service);

  registry = new Registry('somata:registry', registry_methods, registry_options);

}).call(this);
