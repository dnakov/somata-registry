#!/usr/bin/env node
// Generated by CoffeeScript 1.11.1
(function() {
  var BUMP_FACTOR, DEFAULT_HEARTBEAT, DEFAULT_REGISTRY_PORT, EventEmitter, REGISTRY_BIND_HOST, REGISTRY_BIND_PORT, REGISTRY_BIND_PROTO, Registry, TunnelLocal, VERBOSE, argv, checkServices, deregisterService, deregisteredRemoteService, findServices, foundRemoteServices, getHealthyServiceByName, getRemoteServiceByName, getService, getServiceByClientId, getServiceById, heartbeats, host, isHealthy, join, join_string, log, minimist, port, ref, ref1, registerService, registered, registeredRemoteService, registry, registry_methods, registry_options, remote_registered, somata, tunnel, tunnel_local_client, tunnel_remote_client, tunnel_string,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  somata = require('somata');

  minimist = require('minimist');

  log = somata.log;

  EventEmitter = require('events').EventEmitter;

  argv = minimist(process.argv);

  VERBOSE = argv.v || argv.verbose || process.env.SOMATA_VERBOSE || false;

  DEFAULT_REGISTRY_PORT = 8420;

  DEFAULT_HEARTBEAT = 5000;

  REGISTRY_BIND_PROTO = argv.proto || process.env.SOMATA_REGISTRY_BIND_PROTO || 'tcp';

  REGISTRY_BIND_HOST = argv.h || argv.host || process.env.SOMATA_REGISTRY_BIND_HOST || '127.0.0.1';

  REGISTRY_BIND_PORT = parseInt(argv.p || argv.port || process.env.SOMATA_REGISTRY_BIND_PORT || DEFAULT_REGISTRY_PORT);

  BUMP_FACTOR = 1.5;

  registered = {};

  remote_registered = {};

  heartbeats = {};

  registerService = function(client_id, service_instance, cb) {
    var name;
    service_instance.client_id = client_id;
    if (service_instance.heartbeat == null) {
      service_instance.heartbeat = DEFAULT_HEARTBEAT;
    }
    registered[name = service_instance.name] || (registered[name] = {});
    registered[service_instance.name][service_instance.id] = service_instance;
    heartbeats[client_id] = new Date().getTime() + service_instance.heartbeat * 1.5;
    log.s("[Registry.registerSErvice] <" + client_id + "> as " + service_instance.id);
    registry.publish('register', service_instance);
    registry.emit('register', service_instance);
    return cb(null, service_instance);
  };

  deregisterService = function(service_name, service_id, cb) {
    var ref, service_instance;
    log.w("[Registry.deregisterService] " + service_id);
    if (service_instance = (ref = registered[service_name]) != null ? ref[service_id] : void 0) {
      delete heartbeats[service_instance.client_id];
      delete registered[service_name][service_id];
      delete registry.known_pings[service_instance.client_id];
      registry.publish('deregister', service_instance);
      registry.emit('deregister', service_instance);
    }
    return typeof cb === "function" ? cb(null, service_id) : void 0;
  };

  isHealthy = function(service_instance) {
    var is_healthy, next_heartbeat;
    if (service_instance.heartbeat === 0) {
      return true;
    }
    next_heartbeat = heartbeats[service_instance.client_id];
    is_healthy = next_heartbeat > new Date().getTime();
    if (!is_healthy) {
      if (VERBOSE) {
        log.w("Heartbeat overdue by " + (new Date().getTime() - next_heartbeat));
      }
      deregisterService(service_instance.name, service_instance.id);
    }
    return is_healthy;
  };

  checkServices = function() {
    var results, service_id, service_instance, service_instances, service_name;
    results = [];
    for (service_name in registered) {
      service_instances = registered[service_name];
      results.push((function() {
        var results1;
        results1 = [];
        for (service_id in service_instances) {
          service_instance = service_instances[service_id];
          results1.push(isHealthy(service_instance));
        }
        return results1;
      })());
    }
    return results;
  };

  setInterval(checkServices, 2000);

  findServices = function(cb) {
    return cb(null, registered);
  };

  getHealthyServiceByName = function(service_name) {
    var instance, service_id, service_instances;
    service_instances = registered[service_name];
    for (service_id in service_instances) {
      instance = service_instances[service_id];
      if (isHealthy(instance)) {
        return instance;
      }
    }
    return null;
  };

  getRemoteServiceByName = function(service_name) {
    var service_instances;
    service_instances = remote_registered[service_name];
    if ((service_instances != null) && Object.keys(service_instances).length) {
      return service_instances[Object.keys(service_instances)[0]];
    }
  };

  getServiceById = function(service_id) {
    var ref, service_name;
    service_name = service_id.split('~')[0];
    return (ref = registered[service_name]) != null ? ref[service_id] : void 0;
  };

  getServiceByClientId = function(client_id) {
    var instance, service_id, service_instances, service_name;
    for (service_name in registered) {
      service_instances = registered[service_name];
      for (service_id in service_instances) {
        instance = service_instances[service_id];
        if (instance.client_id === client_id) {
          return instance;
        }
      }
    }
    return null;
  };

  getService = function(service_name, cb) {
    var service_instance;
    if (service_instance = getHealthyServiceByName(service_name)) {
      return cb(null, service_instance);
    } else if (service_instance = getRemoteServiceByName(service_name)) {
      return cb(null, service_instance);
    } else {
      log.w("No healthy instances for " + service_name);
      return cb("No healthy instances for " + service_name);
    }
  };

  foundRemoteServices = function(remote_registry) {
    return function(err, remote_services) {
      var results, service_id, service_instance, service_instances, service_name;
      results = [];
      for (service_name in remote_services) {
        service_instances = remote_services[service_name];
        results.push((function() {
          var results1;
          results1 = [];
          for (service_id in service_instances) {
            service_instance = service_instances[service_id];
            results1.push(registeredRemoteService(remote_registry)(service_instance));
          }
          return results1;
        })());
      }
      return results;
    };
  };

  registeredRemoteService = function(remote_registry) {
    return function(service) {
      var name;
      if (service.host === '0.0.0.0') {
        service.host = remote_registry.host;
      } else if (remote_registry.is_tunnel) {
        service.host = REGISTRY_BIND_HOST;
        service.port = REGISTRY_BIND_PORT;
      }
      service.registry = remote_registry;
      remote_registered[name = service.name] || (remote_registered[name] = {});
      return remote_registered[service.name][service.id] = service;
    };
  };

  deregisteredRemoteService = function(remote_registry) {
    return function(service) {
      delete remote_registered[service.name][service.id];
      return registry.publish('deregister', service);
    };
  };

  tunnel_remote_client = null;

  join = function(remote_registry, cb) {
    tunnel_remote_client = new somata.Client({
      registry_host: remote_registry.host,
      registry_port: remote_registry.port || DEFAULT_REGISTRY_PORT
    });
    tunnel_remote_client.registry_connection.on('connect', function() {
      return tunnel_remote_client.remote('registry', 'findServices', foundRemoteServices(remote_registry));
    });
    tunnel_remote_client.registry_connection.on('failure', function() {
      return Object.keys(remote_registered).map(function(service_name) {
        var remote_instances;
        remote_instances = remote_registered[service_name];
        return Object.keys(remote_instances).map(function(service_id) {
          var service;
          service = remote_instances[service_id];
          return deregisteredRemoteService(remote_registry)(service);
        });
      });
    });
    tunnel_remote_client.subscribe('registry', 'register', registeredRemoteService(remote_registry));
    tunnel_remote_client.subscribe('registry', 'deregister', deregisteredRemoteService(remote_registry));
    if (cb != null) {
      cb(null, "Joined to " + remote_registry.host + ":" + remote_registry.port);
    }
    return tunnel_remote_client;
  };

  tunnel = function(remote_registry, cb) {
    remote_registry.is_tunnel = true;
    return join(remote_registry, cb);
  };

  TunnelLocal = (function(superClass) {
    extend(TunnelLocal, superClass);

    function TunnelLocal(options) {
      if (options == null) {
        options = {};
      }
      Object.assign(this, options);
      this.events = new EventEmitter;
      this.service_subscriptions = {};
      this.service_connections = {};
      registry.on('deregister', (function(_this) {
        return function(service_instance) {
          return _this.deregistered(service_instance);
        };
      })(this));
      registry.on('register', (function(_this) {
        return function(service_instance) {};
      })(this));
      return this;
    }

    return TunnelLocal;

  })(somata.Client);

  TunnelLocal.prototype.getServiceInstance = function(service_name, cb) {
    if (service_name === 'registry') {
      return cb(null, {
        host: "localhost",
        port: REGISTRY_BIND_PORT,
        name: 'tunnel'
      });
    } else {
      return getService(service_name, function(err, got) {
        return cb(err, got);
      });
    }
  };

  registry_methods = {
    registerService: registerService,
    deregisterService: deregisterService,
    findServices: findServices,
    getService: getService,
    join: join,
    tunnel: tunnel
  };

  registry_options = {
    rpc_options: {
      proto: REGISTRY_BIND_PROTO,
      host: REGISTRY_BIND_HOST,
      port: REGISTRY_BIND_PORT
    }
  };

  Registry = (function(superClass) {
    extend(Registry, superClass);

    function Registry() {
      return Registry.__super__.constructor.apply(this, arguments);
    }

    Registry.prototype.register = function() {
      log.i("[Registry] Bound to " + REGISTRY_BIND_HOST + ":" + REGISTRY_BIND_PORT);
      if (VERBOSE) {
        return log.d("[Registry.register] Who registers the registry?");
      }
    };

    Registry.prototype.deregister = function(cb) {
      return cb();
    };

    Registry.prototype.handleMethod = function(client_id, message) {
      if (message.service !== 'registry') {
        return tunnel_remote_client.registry_connection.sendMethod(null, 'forwardMethod', [message], (function(_this) {
          return function(err, response) {
            return _this.sendResponse(client_id, message.id, response);
          };
        })(this));
      } else if (message.method === 'forwardMethod') {
        return tunnel_local_client.remote.apply(tunnel_local_client, [message.service, message.method].concat(slice.call(message.args), [function(err, response) {
          return this.sendResponse(client_id, message.id, response);
        }]));
      } else if (message.method === 'registerService') {
        return registerService.apply(null, [client_id].concat(slice.call(message.args), [(function(_this) {
          return function(err, response) {
            return _this.sendResponse(client_id, message.id, response);
          };
        })(this)]));
      } else {
        return Registry.__super__.handleMethod.apply(this, arguments);
      }
    };

    Registry.prototype.tunneled_subscriptions = {};

    Registry.prototype.handleSubscribe = function(client_id, message) {
      var original_message;
      if (message.service !== 'registry') {
        return tunnel_remote_client._subscribe(message.id, 'registry', 'forwardSubscribe', message, (function(_this) {
          return function(response) {
            return _this.sendEvent(client_id, message.id, response);
          };
        })(this));
      } else if (message.type === 'forwardSubscribe') {
        original_message = message.args[0];
        if (this.tunneled_subscriptions[original_message.id]) {
          if (VERBOSE) {
            return log.w('[handleSubscribe local] Subscribe already exists', original_message.id);
          }
        } else {
          if (VERBOSE) {
            log.s('[handleSubscribe local] Creating subscribe for', original_message.id);
          }
          tunnel_local_client._subscribe.apply(tunnel_local_client, [original_message.id, original_message.service, original_message.type].concat(slice.call(original_message.args), [(function(_this) {
            return function(event) {
              return _this.sendEvent(client_id, original_message.id, event);
            };
          })(this)]));
          return this.tunneled_subscriptions[original_message.id] = true;
        }
      } else {
        return Registry.__super__.handleSubscribe.apply(this, arguments);
      }
    };

    Registry.prototype.handleUnsubscribe = function(client_id, message) {
      if (message.service !== 'registry') {
        return tunnel_remote_client.unsubscribe(message.id);
      } else if (this.tunneled_subscriptions[message.id]) {
        delete this.tunneled_subscriptions[message.id];
        return tunnel_local_client.unsubscribe(message.id);
      } else {
        return Registry.__super__.handleUnsubscribe.apply(this, arguments);
      }
    };

    Registry.prototype.gotPing = function(client_id) {
      var heartbeat_interval, service_instance;
      if (service_instance = getServiceByClientId(client_id)) {
        heartbeat_interval = service_instance.heartbeat;
        return heartbeats[client_id] = new Date().getTime() + heartbeat_interval * 1.5;
      }
    };

    return Registry;

  })(somata.Service);

  if (join_string = argv.j || argv.join) {
    ref = join_string.split(':'), host = ref[0], port = ref[1];
    join({
      host: host,
      port: port
    }, function(err, joined) {
      return log.i('[Registry.join] ' + joined);
    });
  }

  if (tunnel_string = argv.t || argv.tunnel) {
    ref1 = tunnel_string.split(':'), host = ref1[0], port = ref1[1];
    tunnel({
      host: host,
      port: port
    }, function(err, tunneled) {
      return log.i('[Registry.tunnel] ' + tunneled);
    });
  }

  registry = new Registry('somata:registry', registry_methods, registry_options);

  tunnel_local_client = new TunnelLocal;

}).call(this);
